<!-- TOC -->

- [模块化的意义](#模块化的意义)
- [为什么需要模块化](#为什么需要模块化)
- [前端模块化历史和方案](#前端模块化历史和方案)
        - [同步加载 CommonJS](#同步加载-commonjs)
        - [异步加载 AMD (Asynchronous Module Definition，异步模块定义)](#异步加载-amd-asynchronous-module-definition异步模块定义)
        - [CMD (Common Module Definition，通用模块定义)](#cmd-common-module-definition通用模块定义)
        - [规范的实现库](#规范的实现库)
    - [es6 原生的模块化方案](#es6-原生的模块化方案)
    - [模块化打包工具 webpack](#模块化打包工具-webpack)
- [组件化](#组件化)
    - [为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点](#为什么要使用模块化都有哪几种方式可以实现模块化各有什么特点)

<!-- /TOC -->

## 模块化的意义

模块化主要体现的是一种分而治之的思想，分而治之就是将一个大问题分解成多个独立的的小问题，最后组合就是大问题的答案。

模块化则是前端最流行的分治手段，模块化可以对功能进行划分，有利于代码的复用和维护。有利于提高团队开发效率





## 为什么需要模块化

- web sites 慢慢变成了 web app
- 随着项目的扩大，代码量越来越大，代码越来越复杂
- 对代码、文件的高度解耦的要求
- 优化上，希望减少 http 请求

随着前端应用越来越复杂，模块化在前端是很有必要的。

## 前端模块化历史和方案

> [模块化](https://www.processon.com/view/link/5c8409bbe4b02b2ce492286a#map)

早起的模块化的方案很简单，就是通过命名空间，匿名闭包的方式，或 module 模式模拟类提供私有和共有方法来实现模块化，但是这些模块都不是以文件为单位，而是以对象为单位。

#### IIFE：使用自执行函数来编写 在一个单独的函数作用域中执行代码，避免变量冲突

#### 同步加载 CommonJS

比如 node.js，使用的便是 CommomJS 规范。通过 require，module.exports，exports 来进行导入和导出，这里 exports 是 module.exports 的一个引用。

CommonJS 的规范： 根据 CommonJS 规范，一个单独的文件就是一个模块。加载模块使用 require 方法，该方法读取一个文件并执行，最后返回文件内部的 exports 对象。

#### 异步加载 AMD (Asynchronous Module Definition，异步模块定义)

采用异步方式加载模块，通过 define 来定义一个模块，通过 require 来引入模块，模块的加载不影响后面语句的执行，所有依赖于这些模块的语句都写在一个回调函数中，加载完毕后，这个回调函数才运行

**CommonJS** 规范**加载模块是同步**的，也就是说**，只有加载完成，才能执行后面的操作**。**AMD** 规范则是**非同步加载模块，允许指定回调函数**。由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范

#### CMD (Common Module Definition，通用模块定义)

- AMD 提倡依赖前置，在定义模块的时候就要声明其依赖的模块
- CMD 提倡就近依赖（按需加载），在用到某个模块的时候再去 require 进来。

#### 规范的实现库

AMD 规范的 require.js 与 CMD 规范的 sea.js

> require.js 主要解决的问题：  
> 管理文件之间的依赖性  
> 避免浏览器因为加载依赖而停止页面渲染，失去响应。

### es6 原生的模块化方案

**_import export/export default_**

### 模块化打包工具 webpack

组件化、模块化开发的模式产生有个问题必然会产生，就是如何把模块、组件加载组合到一起。

本质上 webpack 是一个现代 JavaScript 应用程序的静态模块打包器。它递归的构建一个依赖关系图，其中包含应用程序的每个模块，然后将这些模块打包成一个或多个 bundle.js。
webpack 支持 CommonJS，AMD，ES6 等规范，所以我们在代码中可以使用多种模块加载规范，而且通过 loader，它不仅可以处理 JavaScript，还可以处理像 css，图片等等的静态资源。

webpack 的优势  

1、支持 CommonJS 和 AMD 模块。  
2、支持模块加载器和插件机制，可对模块灵活定制。babel-loader 支持 ES6  
3、可以通过配置，打包成多个文件。有效的利用浏览器的缓存。  
4、将样式文件和图片等静态资源视为模块进行打包。配合 loader 加载器，对资源进行处理。

## 组件化

组件化主要要针对的是 UI 组件的分治，可以提高代码复用性，有利于扩展，团队协作

如何划分：  
页面上每个独立可视的可交互区域视为组件  
每个组件构建的时候对于一个工程目录，组件所需的资源在这个目录下维护，
组件不依赖其他组件 ，高内聚低耦合
功能封装，组件不涉及具体的功能逻辑

### 为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点

模块化可以给我们带来以下好处

- 解决命名冲突
- 提供复用性
- 提高代码可维护性

实现模块化方式：

- 立即执行函数
- AMD 和 CMD
- CommonJS
- ES Module

### 什么是 mvvm

MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。  
Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；  
View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，  
ViewModel 是一个同步 View 和 Model 的对象。

在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。

ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。



Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表

MVVM 源自于经典的 Model–View–Controller（MVC）模式  ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：

![1.png](assets/16ca75871ec53fba)

# [聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/34)

![img](../img/68747470733a2f2f7773322e73696e61696d672e636e2f6c617267652f303036744b665463677931673168316a6b766465396a33306b3030616e7133322e6a7067.jpg)

- **从 M 到 V 的映射（Data Binding）**，这样可以大量节省你人肉来 update View 的代码
- **从 V 到 M 的事件监听（DOM Listeners）**，这样你的 Model 会随着 View 触发事件而改变

**1、M 到 V 实现**

但是仅仅是这样并不够，我们需要知道什么时候来更新 view（ 即 render ），一般来说主要的 VM 做了以下几种选择：

- VM 实例初始化时
- model 动态修改时

其中初始化拿到 model 对象然后 render 没什么好讲的；model 被修改的时候如何监听属性的改变是一个问题，目前有以下几种思路：

- 借助于 Object 的 observe 方法
- 自己在 set，以及数组的常用操作里触发 change 事件
- 手动 setState()，然后在里面触发 change 事件

知道了触发 render 的时机以及如何 render，一个简单的 M 到 V 映射就实现了。

**2、V 到 M 实现**

从 V 到 M 主要由两类（ 虽然本质上都是监听 DOM ）构成，一类是用户自定义的 listener， 一类是 VM 自动处理的含有 value 属性元素的 listener

第一类类似于你在 Vue 里用 v-on 时绑定的那样，VM 在实例化得时候可以将所有用户自定义的 listener 一次性代理到根元素上，这些 listener 可以访问到你的 model 对象，这样你就可以在 listener 中改变 model

第二类类似于对含有 v-model 与 value 元素的自动处理，我们期望的是例如在一个输入框内

```
<input type="text" v-model="message" />
```

输入值，那么我与之对应的 model 属性 message 也会随之改变，相当于 VM 做了一个默认的 listener，它会监听这些元素的改变然后自动改变 model，具体如何实现相信你也明白了



### mvvm 和 mvc 区别

mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到 View 。