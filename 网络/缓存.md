<!-- TOC -->

- [缓存](#%E7%BC%93%E5%AD%98)
    - [缓存方案](#%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88)
    - [资源验证](#%E8%B5%84%E6%BA%90%E9%AA%8C%E8%AF%81)
    - [浏览器缓存、CacheStorage、Web Worker 与 Service Worker](#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98cachestorageweb-worker-%E4%B8%8E-service-worker)
      - [应用缓存](#%E5%BA%94%E7%94%A8%E7%BC%93%E5%AD%98)
      - [CacheStorage](#cachestorage)
      - [Web Worker](#web-worker)

<!-- /TOC -->

# 缓存

Http 的缓存主要利用 header 里的 Cache-control 和 ETag

`Cache-control`主要包含以及几个字段：

- public
  - 指 HTTP 请求返回的资源在所经过的所有路径包括一些中间代理服务器以及发出这个请求的客户端浏览器都可以进行缓存
- private
  - 代表发起请求的浏览器才可以进行缓存
- no-cache
  - 指可以存缓存，但是每次使用都需要去服务端验证
- no-store
  - 本地和代理服务器都不允许去缓存
- no-transform
  - 不允许代理/缓存服务器转换文件格式

到期

- max-age=<seconds\>
  - 缓存到期时间
- s-maxage=<seconds\>
  - 代理服务器专用
- max-stale=<seconds\>
  - 指示客户机可以使用超出 max-age 时间的响应

重新验证

- must-revalidate
  - 设置了 max-age 的资源过期后必须到源服务端验证资源是否还可用
- proxy-revalidate
  - （缓存服务器用）设置了 max-age 的资源过期后必须到源服务端验证资源是否还可用

`ETag`:即用来进行对比缓存，Etag 是服务端资源的一个标识码

当客户端发送第一次请求时服务端会下发当前请求资源的标识码 Etag，下次再请求时，客户端则会通过 header 里的 If-None-Match 将这个标识码 Etag 带上，服务端将客户端传来的 Etag 与最新的资源 Etag 做对比，如果一样，则表示资源没有更新，返回 304。

### 缓存方案

需求：
有的静态资源会设置一个较长的缓存时间，但是我们希望用户还是能使用最新的资源。

解决方案：
在打包完成的文件名上加上一串哈希码，这个哈希码是根据内容进行的哈希计算。
所以，如果你的内容文件没有变，那么这个 hash 码不会变，即这个静态资源的 url 没有变。 而如果内容有变，那么 hash 码也会变，浏览器就会去请求新的资源请求。

普通的缓存机制：
![缓存机制](../img/cache.png)

### 资源验证

如果给 Cache-Control 设置了 no-cache 后，每次要使用资源时浏览器都要到服务器验证缓存是否过期。 如果直接使用缓存，返回码：**304**

如何验证资源是否过期：

- Last-Modified（上次修改时间）

  - 配合 If-Modified-Since 或 If-Unmodified-Since 使用
  - 如果请求的资源头中有 Last-Modified 这个头，这个头指定了一个时间。那么浏览器重新访问资源时就会带上 If-Modified-Since 这个头，其时间是 Last-Modified 的时间，服务器就会拿这个时间去对比上次修改的时间，然后告诉浏览器是否可以直接使用。

- Etag （数据签名）
  - 资源会依据它的内容产生一个唯一的数据签名，如果资源有更新，那么 Etag 就会发生变化。
  - 配合 If-Match 或 If-None-Match 使用

### [浏览器缓存、CacheStorage、Web Worker 与 Service Worker](https://github.com/youngwind/blog/issues/113)

#### 应用缓存

HTML5 规范中设计了应用缓存（Application Cache）这么一个新的概念。通过它，我们可以做离线应用。然而，由于这个 API 的设计有太多的缺陷，被很多人吐槽，最终被废弃。

#### CacheStorage

为了能精细的，可编程的控制缓存，`CacheStorage`被设计出来，有了它就可以对 JS 缓存进行增删改查。

PS：CacheStorage 并非只有在 Service Worker 中才能用，它是一个全局性的 API，你在控制台中也可以访问到 caches 全局变量。

#### Web Worker

总之： 用于当有需要大量计算时，可以使用 web work

一个网页只会有两个线程：GUI 渲染线程和 JS 引擎线程。即便你的 JS 写得再天花乱坠，也只能在一个进程里面执行。然而，JS 引擎线程和 GUI 渲染线程是互斥的，因此在 JS 执行的时候，UI 页面会被阻塞住。**为了在进行高耗时 JS 运算时，UI 页面仍可用，**那么就得另外开辟一个独立的 JS 线程来运行这些高耗时的 JS 代码，这就是 Web Worker。

Web Worker 有两个特点：

1. 只能服务于新建它的页面，不同页面之间不能共享同一个 Web Worker。web work 无权操作 DOM
2. 当页面关闭时，该页面新建的 Web Worker 也会随之关闭，不会常驻在浏览器中。

> shareWorker 是所有浏览器页面所共享，不属于某个 Render 进程，它是一个独立的进程。可以被多个进程所共享，两个脚本都会向 worker 发送消息， 然后使用 port.postMessage()和 port.onmessage 处理从 worker 发送而来的消息

```js
var myWorker = new SharedWorker('worker.js')
myWorker.port.start()
first.onchange = function() {
  myWorker.port.postMessage([first.value, second.value])
  console.log('Message posted to worker')
}

second.onchange = function() {
  myWorker.port.postMessage([first.value, second.value])
  console.log('Message posted to worker')
}

myWorker.port.onmessage = function(e) {
  result1.textContent = e.data
  console.log('Message received from worker')
}
```
